<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GPU Heart Particles</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/misc/GPUComputationRenderer.js"></script>
<script>
const WIDTH = 128; // 128x128 = 16,384 hạt
let camera, scene, renderer, gpuCompute;
let velocityVariable, positionVariable, particleUniforms;

init();
animate();

function init() {
  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 1, 1000);
  camera.position.z = 5;
  scene = new THREE.Scene();

  renderer = new THREE.WebGLRenderer({ antialias: false });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  // GPU Compute
  gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer);
  const dtPosition = gpuCompute.createTexture();
  const dtVelocity = gpuCompute.createTexture();

  fillTextures(dtPosition, dtVelocity);

  positionVariable = gpuCompute.addVariable("texturePosition", positionShader(), dtPosition);
  velocityVariable = gpuCompute.addVariable("textureVelocity", velocityShader(), dtVelocity);

  gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);
  gpuCompute.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);

  positionVariable.material.uniforms.time = { value: 0 };
  velocityVariable.material.uniforms.time = { value: 0 };

  const error = gpuCompute.init();
  if (error !== null) console.error(error);

  // Particles
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(WIDTH * WIDTH * 3);
  const uvs = new Float32Array(WIDTH * WIDTH * 2);

  let p = 0, q = 0;
  for (let i = 0; i < WIDTH; i++) {
    for (let j = 0; j < WIDTH; j++) {
      positions[p++] = 0; positions[p++] = 0; positions[p++] = 0;
      uvs[q++] = i / (WIDTH - 1);
      uvs[q++] = j / (WIDTH - 1);
    }
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

  const material = new THREE.ShaderMaterial({
    uniforms: {
      map: { value: null },
      positionTexture: { value: null },
      pointSize: { value: 2.0 }
    },
    vertexShader: `
      uniform sampler2D positionTexture;
      uniform float pointSize;
      varying vec3 vColor;
      void main() {
        vec4 pos = texture2D(positionTexture, uv);
        vColor = vec3(1.0, 0.0, 0.0);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos.xyz, 1.0);
        gl_PointSize = pointSize;
      }
    `,
    fragmentShader: `
      varying vec3 vColor;
      void main() {
        float d = length(gl_PointCoord - vec2(0.5));
        if (d > 0.5) discard;
        gl_FragColor = vec4(vColor, 1.0 - d*2.0);
      }
    `,
    transparent: true
  });

  const particles = new THREE.Points(geometry, material);
  scene.add(particles);
  particleUniforms = material.uniforms;
}

function fillTextures(texturePosition, textureVelocity) {
  const pos = texturePosition.image.data;
  const vel = textureVelocity.image.data;
  for (let k = 0; k < pos.length; k += 4) {
    pos[k+0] = (Math.random()-0.5)*4; // x
    pos[k+1] = -5.0;                  // y dưới
    pos[k+2] = (Math.random()-0.5)*4; // z
    pos[k+3] = 1;

    vel[k+0] = 0;
    vel[k+1] = 1 + Math.random(); // bay lên
    vel[k+2] = 0;
    vel[k+3] = 1;
  }
}

function positionShader() {
  return `
    uniform float time;
    void main() {
      vec2 uv = gl_FragCoord.xy / resolution.xy;
      vec4 pos = texture2D(texturePosition, uv);
      vec4 vel = texture2D(textureVelocity, uv);
      pos.xyz += vel.xyz * 0.01;
      gl_FragColor = pos;
    }
  `;
}

function velocityShader() {
  return `
    uniform float time;
    void main() {
      vec2 uv = gl_FragCoord.xy / resolution.xy;
      vec4 pos = texture2D(texturePosition, uv);
      vec4 vel = texture2D(textureVelocity, uv);

      // Spiral force
      float angle = time*0.5 + uv.x*10.0;
      vel.x += 0.01 * cos(angle);
      vel.z += 0.01 * sin(angle);

      // Attract to heart shape
      float t = mod(time*0.1, 1.0);
      float x = 16.0 * pow(sin(t), 3.0);
      float y = 13.0 * cos(t) - 5.0 * cos(2.0*t) - 2.0 * cos(3.0*t) - cos(4.0*t);
      float z = 0.0;
      vec3 target = vec3(x, y, z) * 0.05;

      vel.xyz += (target - pos.xyz) * 0.001;

      gl_FragColor = vel;
    }
  `;
}

function animate() {
  requestAnimationFrame(animate);
  const t = performance.now() * 0.001;
  positionVariable.material.uniforms.time.value = t;
  velocityVariable.material.uniforms.time.value = t;
  gpuCompute.compute();

  particleUniforms.positionTexture.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
  renderer.render(scene, camera);
}
</script>
</body>
</html>
